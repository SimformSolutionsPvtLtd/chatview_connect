import 'dart:async';
import 'dart:collection';

import 'package:flutter/widgets.dart';
import 'package:flutter_chatview_models/flutter_chatview_models.dart';
import 'package:uuid/uuid.dart';

import '../../chatview_db_connection.dart';
import '../../database/database_service.dart';
import '../../enum.dart';
import '../../extensions.dart';
import '../../models/chat_room_metadata_model.dart';
import '../../models/chat_room_user_dm.dart';
import '../../models/chat_view_participants_dm.dart';
import '../../models/config/add_message_config.dart';
import '../../models/config/chat_controller_config.dart';
import '../../storage/storage_service.dart';

/// A class responsible for managing the connection to
/// the database and storage services in a chat view context.
final class ChatRoomManager extends ChatController {
  /// Creates and initializes a [ChatRoomManager] instance using an existing
  /// chat room ID.
  ///
  /// This constructor is used when a chat room already exists, and
  /// its participants and messages need to be loaded.
  ///
  /// **Parameters:**
  /// - (required): [chatRoomId] The unique identifier of the chat room.
  /// - (required): [initialMessageList] A list of initial messages to display
  /// in the chat.
  /// - (required): [scrollController] A [ScrollController] to manage scrolling
  /// behavior.
  /// - (required): [service] An instance of [DatabaseTypeServices] that
  /// provides database and storage services.
  /// - (required): [chatRoomParticipants] Contains details about the current
  /// user and other participants in the chat.
  /// - (required): [config] A [ChatControllerConfig] instance that defines
  ///   chat settings such as message listening, user activity tracking, and
  ///   metadata updates.
  ///
  /// **Returns:**
  /// A fully initialized [ChatRoomManager] instance with the provided
  /// chat room details.
  factory ChatRoomManager.fromChatRoomId({
    required String chatRoomId,
    required List<Message> initialMessageList,
    required ScrollController scrollController,
    required DatabaseTypeServices service,
    required ChatViewParticipantsDm chatRoomParticipants,
    required ChatControllerConfig config,
  }) {
    return ChatRoomManager._(
      storage: service.storage,
      database: service.database,
      scrollController: scrollController,
      initialMessageList: initialMessageList,
      currentUser: chatRoomParticipants.currentUser,
      otherUsers: chatRoomParticipants.otherUsers,
    )
      .._config = config
      .._chatRoomId = chatRoomId
      .._currentChatRoomInfo = chatRoomParticipants
      .._isChatRoomCreated = true
      .._init();
  }

  /// Creates and initializes a [ChatRoomManager] for a new one-to-one or
  /// group chat.
  ///
  /// This constructor is used when a chat room does not yet exist and needs
  /// to be created with the specified users.
  ///
  /// **Parameters:**
  /// - (required): [chatRoomType] Defines whether the chat is one-to-one or
  /// group.
  /// - (required): [currentUser] The user who is initiating or joining the
  /// chat.
  /// - (required): [otherUsers] A list of users who will participate in
  /// the chat.
  /// - (required): [initialMessageList] A list of initial messages to display
  /// in the chat.
  /// - (required): [scrollController] A [ScrollController] to manage scrolling
  /// behavior.
  /// - (required): [service] An instance of [DatabaseTypeServices] that
  /// provides database and storage services.
  /// - (required): [config] A [ChatControllerConfig] instance that defines
  ///   chat settings such as message listening, user activity tracking, and
  ///   metadata updates.
  /// - (optional): [chatRoomId] A unique identifier for the chat room.
  /// If `null`, a new chat room ID is generated.
  /// - (optional): [groupName] The name of the group chat
  /// (only applicable for group chats).
  ///   If `null`, a default name is generated by joining participant names.
  /// - (optional): [groupProfile] The profile picture URL for the group chat.
  /// (only applicable for group chats).
  ///
  /// **Behavior:**
  /// - If a `chatRoomId` is provided, it means the chat room already exists.
  /// - If `chatRoomId` is `null`, a new unique ID is generated for the chat.
  /// - If the chat type is **group**, it sets up the group name and profile
  /// picture.
  ///
  /// **Returns:**
  /// A fully initialized [ChatRoomManager] instance.
  factory ChatRoomManager.fromUsers({
    required ChatRoomType chatRoomType,
    required ChatUser currentUser,
    required List<ChatUser> otherUsers,
    required List<Message> initialMessageList,
    required ScrollController scrollController,
    required DatabaseTypeServices service,
    required ChatControllerConfig config,
    String? chatRoomId,
    String? groupName,
    String? groupProfile,
  }) {
    final chatRoomParticipants = ChatViewParticipantsDm(
      chatRoomType: chatRoomType,
      currentUser: currentUser,
      otherUsers: otherUsers,
      groupPhotoUrl: chatRoomType.isGroup ? groupProfile : null,
      groupName: groupName ??
          (chatRoomType.isGroup ? otherUsers.toJoinString(', ') : null),
    );
    return ChatRoomManager._(
      storage: service.storage,
      database: service.database,
      scrollController: scrollController,
      initialMessageList: initialMessageList,
      currentUser: currentUser,
      otherUsers: otherUsers,
    )
      .._config = config
      .._config?.chatRoomInfo?.call(chatRoomParticipants)
      .._chatRoomId = chatRoomId ?? const Uuid().v8()
      .._currentChatRoomInfo = chatRoomParticipants
      .._isChatRoomCreated = chatRoomId != null
      .._init();
  }

  ChatRoomManager._({
    required DatabaseService database,
    required StorageService storage,
    required super.initialMessageList,
    required super.scrollController,
    required super.otherUsers,
    required super.currentUser,
  })  : _storage = storage,
        _database = database;

  final StorageService _storage;
  final DatabaseService _database;

  StreamSubscription<List<Message>>? _messagesStream;
  StreamSubscription<Map<String, ChatRoomUserDm>>? _chatRoomUserStream;
  StreamSubscription<ChatRoomMetadata>? _chatRoomStreamController;
  ChatControllerConfig? _config;
  ChatViewParticipantsDm? _currentChatRoomInfo;

  String? _chatRoomId;

  // This is for identifying that is chat room is created
  bool _isChatRoomCreated = false;

  bool get _isInitialized =>
      _chatRoomUserStream != null || _messagesStream != null;

  ChatRoomType? get _chatRoomType => _currentChatRoomInfo?.chatRoomType;

  /// The unique identifier for the chat room.
  ///
  /// This ID is used to distinguish between different chat rooms.
  /// It can be `null` if the chat room has not been initialized
  /// or assigned yet.
  String get chatRoomId {
    assert(_chatRoomId?.isNotEmpty ?? false, "Chat Room ID can't be empty!");
    return _chatRoomId!;
  }

  /// Initializes streams to monitor chat room activities, including:
  /// - **Metadata updates**: Listens for chat room metadata changes and
  /// invokes the configured callback.
  /// - **User activity tracking**: Monitors typing status and presence updates.
  /// - **Message retrieval**: Fetches messages for the chat room.
  ///
  /// **Behavior:**
  /// - Returns early if the chat room is already created and initialized.
  /// - Tracks user metadata updates if `syncOtherUsersInfo` is enabled.
  /// - If `syncOtherUsersInfo` is not specified, it defaults to `true`.
  void _init() {
    if (!_isChatRoomCreated || _isInitialized) return;

    final syncOtherUsersInfo = _config?.syncOtherUsersInfo ?? true;

    final chatViewParticipants = _currentChatRoomInfo;
    if (chatViewParticipants == null) return;
    final chatRoomType = chatViewParticipants.chatRoomType;
    if (_config?.onChatRoomMetadataChanges
        case final metadataChangesCallback?) {
      _chatRoomStreamController = _database
          .getChatRoomMetadataStream(
            chatId: chatRoomId,
            chatRoomType: chatRoomType,
            userId: chatRoomType.isOneToOne
                ? chatViewParticipants.otherUsers.firstOrNull?.id
                : null,
          )
          .listen(metadataChangesCallback);
    }

    _chatRoomUserStream = _database
        .getChatRoomUsersMetadataStream(
          chatId: chatRoomId,
          observeUserInfoChanges: syncOtherUsersInfo,
        )
        .listen(
          (users) => _listenChatRoomUsersActivityStream(
            users: users,
            syncOtherUsersInfo: syncOtherUsersInfo,
            userActivityChangeCallback: _config?.onUsersActivityChanges,
          ),
        );

    (chatRoomType.isGroup
            ? _database.userAddedInGroupChatTimestamp(chatId: chatRoomId)
            : Future<DateTime?>.value())
        .then(
      (startMessageTimestamp) {
        // TODO(YASH): Handle if received error here.
        _messagesStream = _database
            .getMessagesStream(
              chatId: chatRoomId,
              sortBy: MessageSortBy.createAt,
              sortOrder: MessageSortOrder.asc,
              startFromDateTime: startMessageTimestamp,
            )
            .listen(_listenMessages);
      },
    );
  }

  /// Sends a message and optionally attaches a reply message and message type.
  /// This method is triggered when a user sends a new message in the chat.
  /// It also handles uploading media and stores the message in the database.
  ///
  /// **Parameters:**
  /// - (required): [message] The content of the message being sent.
  /// - (required): [replyMessage] An optional reply to another message, if any.
  /// - (required): [messageType] The type of the message
  /// (e.g., text, image, video).
  ///
  /// Returns a [Future] that completes with the newly sent [Message] object,
  /// or null if the message could not be sent.
  Future<Message?> onSendTap(
    String message,
    ReplyMessage replyMessage,
    MessageType messageType,
  ) async {
    if (_isChatRoomCreated && !_isInitialized) return null;

    final sentByUserId = ChatViewDbConnection.instance.currentUserId;
    if (sentByUserId == null) throw Exception("Sender ID Can't be null");
    return onSendTapFromMessage(
      Message(
        id: const Uuid().v8(),
        createdAt: DateTime.now(),
        message: message,
        sentBy: sentByUserId,
        replyMessage: replyMessage,
        messageType: messageType,
      ),
    );
  }

  /// Sends a message within an active chat room.
  ///
  /// This method is responsible for handling the sending of a new message in
  /// the provided the chat room ID, It also handles uploading media
  /// and stores the message in the database.
  ///
  /// **Parameters:**
  /// - (required): [messageDm] The message object containing the content
  /// and metadata.
  ///
  /// Returns a [Future] that completes with the newly sent [Message] object,
  /// or null if the message could not be sent.
  Future<Message?> onSendTapFromMessage(Message messageDm) async {
    if (_isChatRoomCreated && !_isInitialized) return null;

    final chatRoomId = _chatRoomId;
    if (chatRoomId == null) throw Exception("ChatRoom ID Can't be null");

    if (_isChatRoomCreated) {
      addMessage(messageDm);
    } else {
      final chatViewParticipants = _currentChatRoomInfo;
      if (chatViewParticipants == null) return null;
      final chatRoomType = chatViewParticipants.chatRoomType;
      addMessage(messageDm);
      switch (chatRoomType) {
        case ChatRoomType.oneToOne:
          await _database.createOneToOneUserChat(
            chatRoomId: chatRoomId,
            otherUserId: chatViewParticipants.otherUsers.first.id,
          );
        case ChatRoomType.group:
          final users = chatViewParticipants.otherUsers;
          final usersLength = users.length;
          final lastLength = usersLength - 1;
          final groupNameBuffer = StringBuffer();
          final userIds = <String, Role>{};
          for (var i = 0; i < usersLength; i++) {
            final user = users[i];
            final userName = user.name;
            groupNameBuffer.write(i == lastLength ? userName : '$userName, ');
            userIds[user.id] = Role.admin;
          }
          await _database.createGroupChat(
            chatRoomId: chatRoomId,
            participants: userIds,
            groupName:
                chatViewParticipants.groupName ?? groupNameBuffer.toString(),
          );
      }
      _init();
    }

    // TODO(YASH): Handle failure and success
    return _database.addMessage(
      chatId: chatRoomId,
      message: messageDm,
      useAutoGeneratedId: false,
      addMessageConfig: AddMessageConfig(
        uploadImageToStorage: true,
        // TODO(Yash): Update this once the chatview supports
        //  the network voice message URL on UI.
        uploadVoiceToStorage: false,
        uploadDocument: (message, {fileName, uploadPath}) => _storage.uploadDoc(
          message: message,
          chatId: chatRoomId,
          fileName: fileName,
          uploadPath: uploadPath,
        ),
      ),
    );
  }

  /// Updates the current user document with the current typing status.
  ///
  /// **Parameters:**
  /// - (required) [status] The current typing status of the user.
  Future<void> updateCurrentUserTypingStatus(TypeWriterStatus status) async {
    if (!_isInitialized) return;
    return _database.updateChatRoomUserMetadata(
      chatId: chatRoomId,
      typingStatus: status,
    );
  }

  /// Updates the status of a message to "read" or any other provided status.
  ///
  /// **Parameters:**
  /// - (required): [message] The message whose status needs to be updated.
  Future<void> onMessageRead(Message message) async {
    if (!_isInitialized) return;
    return _database.updateMessage(
      chatId: chatRoomId,
      message: message,
      messageStatus: message.status,
    );
  }

  /// Deletes a message and removes any associated media from storage.
  ///
  /// **Parameters:**
  /// - (required): [message] The message that is being unsent.
  Future<bool> onUnsendTap(Message message) async {
    if (!_isInitialized) return false;

    final initialMessageList = this.initialMessageList;

    final length = initialMessageList.length;

    final lastMessage = length > 0 ? initialMessageList[length - 1] : null;

    final isDeleted = await _database.deleteMessage(
      chatId: chatRoomId,
      message: message,
      deleteImageFromStorage: true,
      deleteVoiceFromStorage: false,
      onDeleteDocument: _storage.deleteDoc,
    );

    final isLastMessage = message.id == lastMessage?.id;

    if (isLastMessage && isDeleted) {
      final secondLastMessage =
          length > 1 ? initialMessageList[length - 2] : null;

      if (!(secondLastMessage == null && (_chatRoomType?.isGroup ?? false))) {
        return _database.updateChatRoom(
          chatId: chatRoomId,
          lastMessage: secondLastMessage,
        );
      }
    }

    return isDeleted;
  }

  /// Updates the reaction of a user on a message with the selected emoji.
  ///
  /// **Parameters:**
  /// - (required): [message] The message to which the user is reacting.
  /// - (required): [emoji] The emoji representing the user's reaction.
  Future<void> userReactionCallback(Message message, String emoji) async {
    if (!_isInitialized) return;
    final userId = ChatViewDbConnection.instance.currentUserId;
    if (userId == null) throw Exception("Sender ID Can't be null");
    return _database.updateMessage(
      message: message,
      chatId: chatRoomId,
      userReaction: (userId: userId, emoji: emoji),
    );
  }

  /// {@macro flutter_chatview_db_connection.DatabaseService.updateGroupChat}
  ///
  /// **Note:**
  /// - This method does **not** restrict updates based on whether the
  /// chat room is one-to-one or a group. If called for a one-to-one chat,
  /// it will still attempt to update the group name without validation.
  Future<bool> updateGroupChat({
    String? groupName,
    String? groupProfilePic,
  }) async {
    if (!_isInitialized) return false;
    return _database.updateGroupChat(
      chatId: chatRoomId,
      groupName: groupName,
      groupProfilePic: groupProfilePic,
    );
  }

  /// {@macro flutter_chatview_db_connection.DatabaseService.addUserInGroup}
  Future<bool> addUserInGroup({
    required String userId,
    required Role role,
    required bool includeAllChatHistory,
  }) async {
    if (!_isInitialized) return false;
    return _database.addUserInGroup(
      role: role,
      userId: userId,
      chatId: chatRoomId,
      includeAllChatHistory: includeAllChatHistory,
    );
  }

  /// Removes a user from the group chat and updates their membership status
  /// to [MembershipStatus.removed].
  ///
  /// **Parameters:**
  /// - (required): [userId] The unique identifier of the user to be removed.
  ///
  /// Returns a [Future] that resolves to `true`
  /// if the user was successfully removed, otherwise `false`.
  Future<bool> removeUserFromGroup({
    required String userId,
    bool deleteGroupIfSingleUser = true,
  }) async {
    if (!_isInitialized) return false;
    return _database.removeUserFromGroup(
      chatId: chatRoomId,
      userId: userId,
      deleteGroupIfSingleUser: deleteGroupIfSingleUser,
      deleteChatDocsFromStorage: _storage.deleteChatMedia,
    );
  }

  /// Allows the current user to leave the group chat by updating their
  /// membership status to [MembershipStatus.left].
  ///
  /// Returns a [Future] that resolves to `true`
  /// if the user successfully left the group, otherwise `false`.
  Future<bool> leaveFromGroup() async {
    if (!_isInitialized) return false;
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) throw Exception("Current User ID can't be null");
    return _database.removeUserFromGroup(
      chatId: chatRoomId,
      userId: currentUserId,
      deleteGroupIfSingleUser: true,
      deleteChatDocsFromStorage: _storage.deleteChatMedia,
    );
  }

  void _listenChatRoomUsersActivityStream({
    required Map<String, ChatRoomUserDm> users,
    required bool syncOtherUsersInfo,
    ValueSetter<Map<String, ChatRoomUserDm>>? userActivityChangeCallback,
  }) {
    if (syncOtherUsersInfo) _listenChatRoomUsersInfoChanges(users);
    _listenChatRoomUsersActivities(users);
    if (userActivityChangeCallback case final callback?) callback(users);
  }

  // TODO(YASH): Typing indicators are only handled for one-to-one chats
  //  because ChatView doesn't support showing profile pictures for multiple
  //  users typing in group chats.
  void _listenChatRoomUsersActivities(Map<String, ChatRoomUserDm> users) {
    final isOneToOneChat = _chatRoomType?.isOneToOne ?? true;
    if (isOneToOneChat) {
      setTypingIndicator = users.values.first.typingStatus.isTyping;
    }
  }

  void _listenChatRoomUsersInfoChanges(Map<String, ChatRoomUserDm> users) {
    final chatUsers = users.values.toList();
    final usersLength = chatUsers.length;

    for (var i = 0; i < usersLength; i++) {
      final chatUser = chatUsers[i].chatUser;
      if (chatUser == null) continue;
      updateOtherUser(chatUser);
    }
    // TODO(YASH): Rebuild chatview once the user details udapted.
  }

  // TODO(YASH): Use unmodifiable list for better performance
  void _listenMessages(List<Message> messages) {
    initialMessageList = messages;
    messageStreamController.sink.add(messages);
  }

  /// Disposes of resources related to chat room and message streams.
  ///
  /// This method is called to release any resources when the chat view is
  /// no longer needed.
  ///
  /// It cancels any active streams and resets the database configuration.
  @override
  void dispose() {
    _chatRoomId = null;
    _chatRoomStreamController?.cancel();
    _chatRoomStreamController = null;
    _chatRoomUserStream?.cancel();
    _chatRoomUserStream = null;
    _messagesStream?.cancel();
    _messagesStream = null;
    _config = null;
    _isChatRoomCreated = false;
    _currentChatRoomInfo = null;
    super.dispose();
  }
}
