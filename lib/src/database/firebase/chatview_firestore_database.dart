import 'package:chatview/chatview.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:rxdart/rxdart.dart';

import '../../chatview_db_connection.dart';
import '../../enum.dart';
import '../../extensions.dart';
import '../../models/chat_room_user_dm.dart';
import '../../models/chat_view_participants_dm.dart';
import '../../models/config/add_message_config.dart';
import '../../models/database_path_config.dart';
import '../../models/message_dm.dart';
import '../../typedefs.dart';
import '../database_service.dart';
import 'chatview_firestore_collections.dart';

/// provides methods for getting, adding, updating and deleting message
/// and messages streams from Firebase Firestore.
final class ChatViewFireStoreDatabase implements DatabaseService {
  static const String _typingStatus = 'typing_status';
  static const String _userStatus = 'user_status';
  static const String _status = 'status';
  static const String _reaction = 'reaction';

  static ChatDatabasePathConfig? _chatDatabaseConfig;

  String? get _userCollection => _chatDatabaseConfig?.userCollectionPath;

  String? _chatRoomCollectionPath({String? chatId}) {
    final newChatId = chatId ?? _chatDatabaseConfig?.chatRoomId;
    final collectionPath =
        '${_chatDatabaseConfig?.chatRoomCollectionPath}/$newChatId';
    assert(
      collectionPath.isValidFirestoreDocument,
      'invalid Firestore document path provided',
    );
    return collectionPath;
  }

  CollectionReference<Message?> _messageCollectionRef({String? chatId}) =>
      ChatViewFireStoreCollections.messageCollection(
        _chatRoomCollectionPath(chatId: chatId),
      );

  @override
  void setConfiguration({required ChatDatabasePathConfig config}) =>
      _chatDatabaseConfig = config;

  @override
  void resetConfiguration() => _chatDatabaseConfig = null;

  @override
  Future<Message?> addMessage(
    Message message, {
    required bool useAutoGeneratedId,
    required AddMessageConfig addMessageConfig,
  }) async {
    final url = await addMessageConfig.uploadDocumentFromMessage(message);
    final messageCollectionRef = _messageCollectionRef();
    final newMessage = message.copyWith(message: url);
    if (useAutoGeneratedId) {
      final result = await messageCollectionRef.add(newMessage);
      return newMessage.copyWith(id: result.id);
    } else {
      await messageCollectionRef.doc(newMessage.id).set(newMessage);
      return newMessage;
    }
  }

  @override
  Stream<List<MessageDm>> getMessagesStream({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
  }) {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messages = docSnapshot.docs;
        final messagesLength = messages.length;
        return [
          for (var i = 0; i < messagesLength; i++)
            if (messages[i].data() case final message?)
              MessageDm(
                message: message.copyWith(id: messages[i].id),
                snapshot: messages[i],
              ),
        ];
      },
    );
  }

  @override
  Stream<Map<Message, DocumentType>> getMessagesStreamWithOperationType({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
  }) {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messagesChanges = docSnapshot.docChanges;
        final messagesChangesLength = messagesChanges.length;
        final messages = <Message, DocumentType>{};
        for (var i = 0; i < messagesChangesLength; i++) {
          final changedDoc = messagesChanges[i];
          final messageDoc = changedDoc.doc;
          final message = messageDoc.data()?.copyWith(id: messageDoc.id);
          if (message == null) continue;
          messages[message] = changedDoc.type.toDocumentType();
        }
        return messages;
      },
    );
  }

  @override
  Future<List<MessageDm>> getMessages({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
  }) async {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
    );

    final result = await messageCollectionRef.get();
    final docs = result.docs;
    final docsLength = docs.length;
    return [
      for (var i = 0; i < docsLength; i++)
        if (docs[i].data() case final message?)
          MessageDm(
            message: message.copyWith(id: docs[i].id),
            snapshot: docs[i],
          ),
    ];
  }

  @override
  Future<bool> deleteMessage(
    Message message, {
    required DeleteDocumentCallback onDeleteDocument,
    required bool deleteImageFromStorage,
    required bool deleteVoiceFromStorage,
  }) async {
    final messageType = message.messageType;
    if (messageType.isImage && deleteImageFromStorage) {
      await onDeleteDocument(message);
    } else if (messageType.isVoice && deleteVoiceFromStorage) {
      await onDeleteDocument(message);
    }
    await _messageCollectionRef().doc(message.id).delete();
    return true;
  }

  @override
  Future<void> updateMessage(
    Message message, {
    MessageStatus? messageStatus,
    UserReactionCallback? userReaction,
  }) async {
    final data = <String, dynamic>{
      if (messageStatus case final status?) _status: status.name,
      if (userReaction != null) _reaction: message.reaction.toJson(),
    };

    if (data.isEmpty) return;

    return _messageCollectionRef().doc(message.id).update(data);
  }

  @override
  Stream<List<ChatRoomUserDm>> getChatRoomParticipantsStream({
    bool includeCurrentUser = true,
    int? limit,
    String? chatId,
  }) {
    final collectionPath = _chatRoomCollectionPath(chatId: chatId);

    final userCollection =
        ChatViewFireStoreCollections.chatUsersCollection(collectionPath)
            .toQuery(limit: limit);

    return userCollection.snapshots().switchMap(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        final docsLength = docs.length;
        final listOfChatUserStream = <Stream<ChatRoomUserDm>>[];
        final currentUserId = ChatViewDbConnection.instance.currentUserId;
        for (var i = 0; i < docsLength; i++) {
          final doc = docs[i];
          final userId = doc.id;
          if (!includeCurrentUser && userId == currentUserId) {
            continue;
          }
          final chatRoomUser = doc.data();
          if (chatRoomUser == null) continue;
          listOfChatUserStream.add(
            getUserStreamById(userId: userId).map(
              (chatUser) => chatRoomUser.copyWith(chatUser: chatUser),
            ),
          );
        }
        return Rx.combineLatestList(listOfChatUserStream);
      },
    );
  }

  @override
  Stream<List<ChatUser>> getUsersStream({int? limit}) {
    final userCollection =
        ChatViewFireStoreCollections.usersCollection().toQuery(limit: limit);

    return userCollection.snapshots().map(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        final docsLength = docs.length;
        return <ChatUser>[
          for (var i = 0; i < docsLength; i++)
            if (docs[i].data() case final chatUser?) chatUser,
        ];
      },
    );
  }

  @override
  Stream<ChatUser?> getUserStreamById({required String userId}) {
    final userCollection =
        ChatViewFireStoreCollections.usersCollection(_userCollection)
            .doc(userId);
    return userCollection.snapshots().map((chatUserDoc) => chatUserDoc.data());
  }

  @override
  Future<ChatViewParticipantsDm?> getChatRoomParticipants() async {
    final results = await _getChatRoomUsersWithDetails();
    final resultsLength = results.length;

    ChatUser? currentUser;
    final otherUsers = <ChatUser>[];

    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    for (var i = 0; i < resultsLength; i++) {
      final user = results[i].chatUser;
      if (user == null) continue;
      if (user.id == currentUserId) {
        currentUser = user;
      } else {
        otherUsers.add(user);
      }
    }

    if (currentUser == null || otherUsers.isEmpty) return null;

    return ChatViewParticipantsDm(
      currentUser: currentUser,
      otherUsers: otherUsers,
    );
  }

  @override
  Future<void> updateChatRoomUserMetadata({
    TypeWriterStatus? typingStatus,
    UserStatus? userStatus,
  }) async {
    final userId = ChatViewDbConnection.instance.currentUserId;
    if (userId == null) throw Exception("Sender ID Can't be null");

    final data = <String, dynamic>{
      if (typingStatus case final status?) _typingStatus: status.name,
      if (userStatus case final status?) _userStatus: status.name,
    };

    if (data.isEmpty) return;

    return ChatViewFireStoreCollections.chatUsersCollection(
      _chatRoomCollectionPath(),
    ).doc(userId).update(data);
  }

  @override
  Stream<Map<String, ChatRoomUserDm>> getChatRoomUsersMetadataStream({
    int? limit,
  }) {
    final userCollection = ChatViewFireStoreCollections.chatUsersCollection(
      _chatRoomCollectionPath(),
    ).toQuery(limit: limit);

    return userCollection.snapshots().map(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        final docsLength = docs.length;
        final users = <String, ChatRoomUserDm>{};
        final currentUserId = ChatViewDbConnection.instance.currentUserId;
        for (var i = 0; i < docsLength; i++) {
          final chatRoomUser = docs[i].data();
          if (chatRoomUser == null) continue;
          final userId = chatRoomUser.userId;
          if (userId == currentUserId) continue;
          users[userId] = chatRoomUser;
        }
        return users;
      },
    );
  }

  Future<List<ChatRoomUserDm>> _getChatRoomUsersWithDetails({
    int? limit,
    DocumentSnapshot<ChatRoomUserDm?>? startAfterDocument,
  }) async {
    final userCollection = ChatViewFireStoreCollections.chatUsersCollection(
      _chatRoomCollectionPath(),
    ).toQuery(limit: limit, startAfterDocument: startAfterDocument);

    final userSnapshot = await userCollection.get();

    final docs = userSnapshot.docs;
    final docsLength = docs.length;
    final chatRoomUsers = <String, ChatRoomUserDm>{};

    final chatRoomUsersInfoFutures = <Future<void>>[];

    for (var i = 0; i < docsLength; i++) {
      final doc = docs[i];
      final chatRoomUser = doc.data();
      if (chatRoomUser == null) continue;
      final userId = doc.id;
      chatRoomUsers[userId] = chatRoomUser;
      chatRoomUsersInfoFutures.add(
        ChatViewFireStoreCollections.usersCollection(_userCollection)
            .doc(userId)
            .get()
            .then(
          (chatUserDoc) {
            final userData = chatUserDoc.data();
            final chatRoomUser = chatRoomUsers[userId];
            if (chatRoomUser != null) {
              chatRoomUsers[userId] = chatRoomUser.copyWith(chatUser: userData);
            }
          },
        ),
      );
    }

    await Future.wait(chatRoomUsersInfoFutures);
    return chatRoomUsers.values.toList();
  }
}
