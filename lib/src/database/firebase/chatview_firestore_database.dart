import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_chatview_models/flutter_chatview_models.dart';
import 'package:rxdart/rxdart.dart';
import 'package:uuid/uuid.dart';

import '../../chatview_db_connection.dart';
import '../../enum.dart';
import '../../extensions.dart';
import '../../models/chat_room_dm.dart';
import '../../models/chat_room_metadata_model.dart';
import '../../models/chat_room_user_dm.dart';
import '../../models/chat_view_participants_dm.dart';
import '../../models/config/add_message_config.dart';
import '../../models/config/chat_database_path_config.dart';
import '../../models/config/chat_view_firestore_path_config.dart';
import '../../models/message_dm.dart';
import '../../models/user_chat_dm.dart';
import '../../models/user_chats_conversation_dm.dart';
import '../../typedefs.dart';
import '../database_service.dart';
import 'chatview_firestore_collections.dart';

/// provides methods for getting, adding, updating and deleting message
/// and messages streams from Firebase Firestore.
final class ChatViewFireStoreDatabase implements DatabaseService {
  static const String _typingStatus = 'typing_status';
  static const String _userStatus = 'user_status';
  static const String _status = 'status';
  static const String _reaction = 'reaction';
  static const String _lastMessage = 'last_message';
  static const String _groupName = 'group_name';
  static const String _groupPhotoUrl = 'group_photo_url';
  static const String _createdAt = 'createdAt';
  static const String _membershipStatus = 'membership_status';
  static const String _membershipStatusTimestamp =
      'membership_status_timestamp';

  static String? _chatRoomId;

  ChatDatabasePathConfig get _chatDatabaseConfig =>
      ChatViewDbConnection.instance.getChatDatabasePathConfig;

  String? get _userCollection => _chatDatabaseConfig.userCollectionPath;

  ChatViewFireStoreCollectionNameConfig get _firestorePathConfig =>
      ChatViewDbConnection.instance.getChatViewFireStorePathConfig;

  String _chatRoomCollectionPath({String? chatId}) {
    final newChatId = chatId ?? _chatRoomId;
    final collectionPath = '${_firestorePathConfig.chats}/$newChatId';
    assert(
      collectionPath.isValidFirestoreDocument,
      'invalid Firestore document path provided',
    );
    return collectionPath;
  }

  CollectionReference<Message?> _messageCollectionRef({String? chatId}) =>
      ChatViewFireStoreCollections.messageCollection(
        _chatRoomCollectionPath(chatId: chatId),
      );

  CollectionReference<ChatUser?> _usersollectionRef() =>
      ChatViewFireStoreCollections.usersCollection(_userCollection);

  @override
  String? get chatRoomId => _chatRoomId;

  @override
  void setChatRoom({required String chatRoomId}) => _chatRoomId = chatRoomId;

  @override
  void resetChatRoom() => _chatRoomId = null;

  @override
  Future<Message?> addMessage(
    Message message, {
    required bool useAutoGeneratedId,
    required AddMessageConfig addMessageConfig,
  }) async {
    if (_chatRoomId == null) throw Exception("Chat Room ID can't be null");

    final url = await addMessageConfig.uploadDocumentFromMessage(message);
    final messageCollectionRef = _messageCollectionRef();
    final newMessage = message.copyWith(message: url);

    Message? updatedMessage;

    if (useAutoGeneratedId) {
      final result = await messageCollectionRef.add(newMessage);
      updatedMessage = newMessage.copyWith(id: result.id);
    } else {
      await messageCollectionRef.doc(newMessage.id).set(newMessage);
      updatedMessage = newMessage;
    }

    // TODO(Yash): Switch to reading last message from message collection
    //  instead of updating last message in chat room document.
    await updateChatRoom(lastMessage: updatedMessage);

    return updatedMessage;
  }

  @override
  Stream<List<MessageDm>> getMessagesStreamWithSnapshot({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
    DateTime? startFromDateTime,
  }) {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
      whereFieldName: _createdAt,
      whereFieldIsGreaterThanOrEqualTo: startFromDateTime,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messages = docSnapshot.docs;
        final messagesLength = messages.length;
        return [
          for (var i = 0; i < messagesLength; i++)
            if (messages[i].data() case final message?)
              MessageDm(
                message: message.copyWith(id: messages[i].id),
                snapshot: messages[i],
              ),
        ];
      },
    );
  }

  @override
  Stream<List<Message>> getMessagesStream({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
    DateTime? startFromDateTime,
  }) {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      limit: limit,
      sortBy: sortBy,
      sortOrder: sortOrder,
      whereFieldName: _createdAt,
      startAfterDocument: startAfterDocument,
      whereFieldIsGreaterThanOrEqualTo: startFromDateTime,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messages = docSnapshot.docs;
        final messagesLength = messages.length;
        return [
          for (var i = 0; i < messagesLength; i++)
            if (messages[i].data() case final message?) message,
        ];
      },
    );
  }

  @override
  Stream<Map<Message, DocumentType>> getMessagesStreamWithOperationType({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
  }) {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messagesChanges = docSnapshot.docChanges;
        final messagesChangesLength = messagesChanges.length;
        final messages = <Message, DocumentType>{};
        for (var i = 0; i < messagesChangesLength; i++) {
          final changedDoc = messagesChanges[i];
          final messageDoc = changedDoc.doc;
          final message = messageDoc.data()?.copyWith(id: messageDoc.id);
          if (message == null) continue;
          messages[message] = changedDoc.type.toDocumentType();
        }
        return messages;
      },
    );
  }

  @override
  Future<List<MessageDm>> getMessages({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
  }) async {
    final messageCollectionRef = _messageCollectionRef().toMessageQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
    );

    final result = await messageCollectionRef.get();
    final docs = result.docs;
    final docsLength = docs.length;
    return [
      for (var i = 0; i < docsLength; i++)
        if (docs[i].data() case final message?)
          MessageDm(
            message: message.copyWith(id: docs[i].id),
            snapshot: docs[i],
          ),
    ];
  }

  @override
  Future<bool> deleteMessage(
    Message message, {
    required DeleteDocumentCallback onDeleteDocument,
    required bool deleteImageFromStorage,
    required bool deleteVoiceFromStorage,
  }) async {
    final messageType = message.messageType;
    if (messageType.isImage && deleteImageFromStorage) {
      await onDeleteDocument(message);
    } else if (messageType.isVoice && deleteVoiceFromStorage) {
      await onDeleteDocument(message);
    }
    await _messageCollectionRef().doc(message.id).delete();
    return true;
  }

  @override
  Future<void> updateMessage(
    Message message, {
    MessageStatus? messageStatus,
    UserReactionCallback? userReaction,
  }) async {
    final data = <String, dynamic>{
      if (messageStatus case final status?) _status: status.name,
      if (userReaction != null) _reaction: message.reaction.toJson(),
    };

    if (data.isEmpty) return;

    await _messageCollectionRef().doc(message.id).update(data);

    await updateChatRoom(lastMessage: message.copyWith(status: messageStatus));
  }

  @override
  Stream<List<ChatRoomUserDm>> getChatRoomParticipantsStream({
    bool includeCurrentUser = true,
    int? limit,
    String? chatId,
  }) {
    final collectionPath = _chatRoomCollectionPath(chatId: chatId);

    final currentChatID = collectionPath.chatId ?? '';

    if (currentChatID.isEmpty) {
      return Stream.error('Chat ID not found from path: $collectionPath');
    }

    final userCollection =
        ChatViewFireStoreCollections.chatUsersCollection(collectionPath)
            .toQuery(limit: limit);

    return userCollection.snapshots().switchMap(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        if (docs.isEmpty) {
          return Stream.error('No users found in chat ID: $currentChatID');
        }
        final docsLength = docs.length;
        final listOfChatUserStream = <Stream<ChatRoomUserDm>>[];
        final currentUserId = ChatViewDbConnection.instance.currentUserId;
        for (var i = 0; i < docsLength; i++) {
          final doc = docs[i];
          final userId = doc.id;
          if (!includeCurrentUser && userId == currentUserId) {
            continue;
          }
          final chatRoomUser = doc.data();
          if (chatRoomUser == null) continue;
          listOfChatUserStream.add(
            _getUserInfoWithStatusStream(userId).map(
              (userResult) => chatRoomUser.copyWith(
                chatUser: userResult.user,
                userStatus: userResult.userStatus,
              ),
            ),
          );
        }
        return listOfChatUserStream.isEmpty
            ? Stream.value([])
            : Rx.combineLatestList(listOfChatUserStream);
      },
    );
  }

  @override
  Stream<List<ChatUser>> getUsersStream({int? limit}) {
    final userCollection = _usersollectionRef().toQuery(limit: limit);

    return userCollection.snapshots().map(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        final docsLength = docs.length;
        return <ChatUser>[
          for (var i = 0; i < docsLength; i++)
            if (docs[i].data() case final chatUser?) chatUser,
        ];
      },
    );
  }

  @override
  Future<List<ChatUser>> getUsers({int? limit}) async {
    final userCollection = _usersollectionRef().toQuery(limit: limit);
    final userSnapshot = await userCollection.get();
    final docs = userSnapshot.docs;
    final docsLength = docs.length;
    return <ChatUser>[
      for (var i = 0; i < docsLength; i++)
        if (docs[i].data() case final chatUser?) chatUser,
    ];
  }

  @override
  Stream<ChatUser?> getUserStreamById({required String userId}) {
    return _usersollectionRef()
        .doc(userId)
        .snapshots()
        .distinct((previous, next) => previous.data() == next.data())
        .map((chatUserDoc) => chatUserDoc.data());
  }

  @override
  Future<ChatViewParticipantsDm?> getChatRoomParticipants() async {
    if (chatRoomId?.isEmpty ?? true) return null;

    final chatRoomResult = await ChatViewFireStoreCollections.chatCollection()
        .doc(chatRoomId)
        .get();

    final chatRoom = chatRoomResult.data();

    if (chatRoom == null) return null;

    final results = await _getChatRoomUsersWithDetails();
    final resultsLength = results.length;

    ChatUser? currentUser;
    final otherUsers = <ChatUser>[];

    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    for (var i = 0; i < resultsLength; i++) {
      final user = results[i].chatUser;
      if (user == null) continue;
      if (user.id == currentUserId) {
        currentUser = user;
      } else {
        otherUsers.add(user);
      }
    }

    if (currentUser == null || otherUsers.isEmpty) return null;

    return ChatViewParticipantsDm(
      chatRoomType: chatRoom.chatRoomType,
      groupName: chatRoom.groupName,
      groupPhotoUrl: chatRoom.groupPhotoUrl,
      currentUser: currentUser,
      otherUsers: otherUsers,
    );
  }

  @override
  Future<void> updateChatRoomUserMetadata({
    String? userId,
    String? chatId,
    TypeWriterStatus? typingStatus,
    UserStatus? userStatus,
    MembershipStatus? membershipStatus,
  }) async {
    final newUserId = userId ?? ChatViewDbConnection.instance.currentUserId;
    if (newUserId == null) throw Exception("Sender ID Can't be null");

    final newChatId = chatId ?? _chatRoomId;
    if (newChatId == null) throw Exception("Chat Room ID Can't be null");

    final data = <String, dynamic>{
      if (typingStatus case final status?) _typingStatus: status.name,
      if (userStatus case final status?) _userStatus: status.name,
      if (membershipStatus case final status?) ...{
        _membershipStatus: status.name,
        _membershipStatusTimestamp: FieldValue.serverTimestamp(),
      },
    };

    if (data.isEmpty) return;

    return ChatViewFireStoreCollections.chatUsersCollection(
      _chatRoomCollectionPath(chatId: newChatId),
    ).doc(newUserId).update(data);
  }

  @override
  Future<bool> updateCurrentUserStatus(UserStatus userStatus) async {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) throw Exception("Current ID can't be null");
    try {
      await ChatViewFireStoreCollections.userChatCollection()
          .doc(currentUserId)
          .update(UserChatDm(userStatus: userStatus).toJson());
      return true;
    } on FirebaseException catch (exception) {
      switch (FirestoreExceptionType.fromCode(exception.code)) {
        case FirestoreExceptionType.notFound:
          return _setCurrentUserStatus(userId: currentUserId);
        case FirestoreExceptionType.unknown:
          return false;
      }
    }
  }

  Future<bool> _setCurrentUserStatus({
    String? userId,
    UserStatus userStatus = UserStatus.offline,
  }) async {
    try {
      await ChatViewFireStoreCollections.userChatCollection()
          .doc(userId)
          .set(UserChatDm(userStatus: userStatus));
      return true;
    } catch (_) {
      return false;
    }
  }

  @override
  Stream<Map<String, ChatRoomUserDm>> getChatRoomUsersMetadataStream({
    required bool observeUserInfoChanges,
    int? limit,
  }) {
    final userCollection = ChatViewFireStoreCollections.chatUsersCollection(
      _chatRoomCollectionPath(),
    ).toQuery(limit: limit);

    return userCollection.snapshots().switchMap(
      (userSnapshot) {
        final docs = userSnapshot.docs;
        final docsLength = docs.length;
        final users = <String, ChatRoomUserDm>{};
        final currentUserId = ChatViewDbConnection.instance.currentUserId;
        for (var i = 0; i < docsLength; i++) {
          final chatRoomUser = docs[i].data();
          if (chatRoomUser == null) continue;
          final userId = chatRoomUser.userId;
          if (userId == currentUserId) continue;
          users[userId] = chatRoomUser;
        }
        if (!observeUserInfoChanges) return Stream.value(users);

        final newUsers = users.values.toList();
        final usersLength = newUsers.length;
        final chatRoomUserStreamWithInfo = <Stream<ChatRoomUserDm>>[
          for (var i = 0; i < usersLength; i++)
            if (newUsers[i] case final chatRoomUser)
              _getUserInfoWithStatusStream(chatRoomUser.userId).map(
                (userResult) {
                  final user = chatRoomUser.copyWith(
                    chatUser: userResult.user,
                    userStatus: userResult.userStatus,
                  );
                  users[chatRoomUser.userId] = user;
                  return user;
                },
              ),
        ];

        return Rx.combineLatest(chatRoomUserStreamWithInfo, (_) => users);
      },
    );
  }

  Future<List<ChatRoomUserDm>> _getChatRoomUsersWithDetails({
    bool includeCurrentUser = true,
  }) async {
    final collectionPath = _chatRoomCollectionPath();

    final currentChatID = collectionPath.chatId ?? '';

    if (currentChatID.isEmpty) {
      return throw Exception('Chat ID not found from path: $collectionPath');
    }

    final userCollectionSnapshot =
        await ChatViewFireStoreCollections.chatUsersCollection(collectionPath)
            .get();

    final docs = userCollectionSnapshot.docs;
    if (docs.isEmpty) {
      throw Exception('No users found in chat ID: $currentChatID');
    }

    final docsLength = docs.length;
    final chatRoomUsers = <String, ChatRoomUserDm>{};
    final chatRoomUsersInfoFutures = <Future<void>>[];
    final currentUserId = ChatViewDbConnection.instance.currentUserId;

    for (var i = 0; i < docsLength; i++) {
      final doc = docs[i];
      final userId = doc.id;
      if (!includeCurrentUser && userId == currentUserId) {
        continue;
      }
      final chatRoomUser = doc.data();
      if (chatRoomUser == null) continue;
      chatRoomUsers[userId] = chatRoomUser;
      chatRoomUsersInfoFutures.add(
        _usersollectionRef().doc(userId).get().then(
          (chatUserDoc) {
            final userData = chatUserDoc.data() ??
                ChatUser(id: userId, name: 'Unknown User');
            final chatRoomUser = chatRoomUsers[userId];
            if (chatRoomUser != null) {
              chatRoomUsers[userId] = chatRoomUser.copyWith(chatUser: userData);
            }
          },
        ),
      );
    }

    await Future.wait(chatRoomUsersInfoFutures);
    return chatRoomUsers.values.toList();
  }

  @override
  Stream<int> getUnreadMessagesCount(
    String chatId, {
    DateTime? startMessageFromDateTime,
  }) {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;

    final chatRoomCollectionRef =
        _messageCollectionRef(chatId: chatId).toMessageQuery(
      sortBy: MessageSortBy.none,
      sortOrder: MessageSortOrder.desc,
      whereFieldName: _createdAt,
      whereFieldIsGreaterThanOrEqualTo:
          startMessageFromDateTime?.toIso8601String(),
    );

    return chatRoomCollectionRef.snapshots().map(
      (messageSnapshot) {
        final docs = messageSnapshot.docs;
        final docsLength = docs.length;
        var count = 0;
        for (var i = 0; i < docsLength; i++) {
          final message = docs[i].data();
          if (message == null ||
              message.sentBy == currentUserId ||
              message.status.isRead) {
            continue;
          }
          count++;
        }
        return count;
      },
    );
  }

  @override
  Stream<List<ChatRoomDm>> getChats({
    required ChatSortBy sortBy,
    required bool showEmptyMessagesChats,
    required bool fetchUnreadMessageCount,
    int? limit,
  }) {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) {
      return Stream.error('Current User with ID $currentUserId not found!');
    }

    final chatRoomCollection =
        ChatViewFireStoreCollections.userChatsConversationCollection(
      userId: currentUserId,
    ).toQuery(limit: limit);

    return chatRoomCollection.snapshots().switchMap(
      (userChatsSnapshot) {
        final docs = userChatsSnapshot.docs;
        if (docs.isEmpty) return Stream.value([]);
        final docsLength = docs.length;
        final chatStreams = <Stream<ChatRoomDm?>>[
          for (var i = 0; i < docsLength; i++)
            ChatViewFireStoreCollections.chatCollection()
                .doc(docs[i].id)
                .snapshots()
                .switchMap(
              (chatRoomSnapshot) {
                final chatRoom = chatRoomSnapshot.data();
                if (chatRoom == null) return Stream.value(null);
                if (!showEmptyMessagesChats &&
                    chatRoom.chatRoomType.isOneToOne &&
                    chatRoom.lastMessage == null) {
                  return Stream.value(null);
                }
                final chatId = chatRoomSnapshot.id;

                return getChatRoomParticipantsStream(
                  // Added group check as to get timestamp of current user
                  // for when they joined the group for count unread messages.
                  includeCurrentUser: chatRoom.chatRoomType.isGroup,
                  chatId: chatId,
                ).switchMap(
                  (users) => _getChatRoomFromChatRoomParticipants(
                    users: users,
                    chatRoom: chatRoom,
                    fetchUnreadMessageCount: fetchUnreadMessageCount,
                  ),
                );
              },
            ),
        ];
        return CombineLatestStream(
          chatStreams,
          (chats) {
            final chatsLength = chats.length;
            final nonEmptyChats = [
              for (var i = 0; i < chatsLength; i++)
                if (chats[i] case final chat?) chat,
            ];
            if (sortBy.isNewestFirst) {
              nonEmptyChats.sort(
                (a, b) =>
                    b.lastMessage?.createdAt
                        .compareTimestamp(a.lastMessage?.createdAt) ??
                    0,
              );
            }
            return nonEmptyChats;
          },
        );
      },
    );
  }

  Stream<ChatRoomDm> _getChatRoomFromChatRoomParticipants({
    required ChatRoomDm chatRoom,
    required List<ChatRoomUserDm> users,
    required bool fetchUnreadMessageCount,
  }) {
    ChatRoomUserDm? currentUser;
    final List<ChatRoomUserDm> otherUsers;
    if (chatRoom.chatRoomType.isGroup) {
      final result = _getChatRoomParticipant(users);
      currentUser = result.currentUser;
      otherUsers = result.otherUsers;
    } else {
      otherUsers = users;
    }

    final membershipTimestamp = currentUser?.membershipStatusTimestamp;

    final unreadMessagesCountStream = fetchUnreadMessageCount
        ? getUnreadMessagesCount(
            chatRoom.chatId,
            startMessageFromDateTime: membershipTimestamp,
          )
        : Stream.value(0);

    final isMessageBeforeMembership =
        membershipTimestamp.isMessageBeforeMembership(
      chatRoom.lastMessage?.createdAt,
    );

    return unreadMessagesCountStream.map(
      (unreadMessagesCount) => chatRoom.copyWith(
        forceNullValue: true,
        users: otherUsers,
        chatId: chatRoom.chatId,
        groupName: chatRoom.groupName,
        chatRoomType: chatRoom.chatRoomType,
        groupPhotoUrl: chatRoom.groupPhotoUrl,
        chatRoomCreateBy: chatRoom.chatRoomCreateBy,
        unreadMessagesCount: unreadMessagesCount,
        lastMessage: isMessageBeforeMembership ? null : chatRoom.lastMessage,
      ),
    );
  }

  @override
  Future<String?> createOneToOneUserChat(
    String otherUserId, {
    String? chatRoomId,
  }) async {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) {
      throw Exception("Current user ID can't be null!");
    }

    if (otherUserId == currentUserId) {
      throw Exception("otherUserId can't be same!");
    }

    final isUsersExists = await Future.wait([
      _isUserExists(currentUserId),
      _isUserExists(otherUserId),
    ]);

    final isBothUserExists = (isUsersExists.firstOrNull ?? false) &&
        (isUsersExists.lastOrNull ?? false);

    if (!isBothUserExists) {
      throw Exception('User ID ($otherUserId) or ($currentUserId) not exists');
    }

    final chatId = await _isChatExists(otherUserId);
    if (chatId != null) return chatId;

    final newChatId = await _createChatForOneToOne(
      otherUserId,
      chatRoomId: chatRoomId,
    );

    if (newChatId?.isEmpty ?? true) throw Exception('Unable to create a chat');

    final result = await Future.wait([
      _createChatInUserChats(
        chatId: newChatId!,
        currentUserId: currentUserId,
        otherUserId: otherUserId,
      ),
      _createChatInUserChats(
        chatId: newChatId,
        currentUserId: otherUserId,
        otherUserId: currentUserId,
      ),
    ]);

    final isCurrentUserChatRoomCreated = result.firstOrNull ?? false;
    final isOtherUserChatRoomCreated = result.lastOrNull ?? false;

    if (isCurrentUserChatRoomCreated && isOtherUserChatRoomCreated) {
      return newChatId;
    } else if (isCurrentUserChatRoomCreated && !isOtherUserChatRoomCreated) {
      await _deleteChatFromUserChats(
        currentUserId: otherUserId,
        chatId: newChatId,
      );
      return null;
    } else if (isOtherUserChatRoomCreated && !isCurrentUserChatRoomCreated) {
      await _deleteChatFromUserChats(
        currentUserId: currentUserId,
        chatId: newChatId,
      );
      return null;
    } else {
      return null;
    }
  }

  @override
  Future<String?> createGroupChat({
    required String groupName,
    required Map<String, Role> userIds,
    String? groupProfilePic,
    String? chatRoomId,
  }) async {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) {
      throw Exception("Current user ID can't be null!");
    }

    if (userIds.isEmpty) throw Exception("User IDs can't be empty!");

    final ids = userIds.keys.toList();

    if (ids.contains(currentUserId)) {
      throw Exception("userIds can't contains current user ID!");
    }

    final userIdsLength = ids.length;

    final isUsersExistsUserInCollection = await Future.wait([
      _isUserExists(currentUserId),
      for (var i = 0; i < userIdsLength; i++) _isUserExists(ids[i]),
    ]);

    final isAllUserExistsInUserCollection = isUsersExistsUserInCollection.fold(
      true,
      (value, isUserExist) => value && isUserExist,
    );

    if (!isAllUserExistsInUserCollection) {
      throw Exception(
        'Some of User IDs($userIds) or ($currentUserId) not exists',
      );
    }

    final chatId = chatRoomId ?? const Uuid().v8();

    final isChatCreated = await _createChat(
      chatId: chatId,
      chatRoom: ChatRoomDm(
        chatId: chatId,
        groupName: groupName,
        groupPhotoUrl: groupProfilePic,
        chatRoomCreateBy: currentUserId,
        chatRoomType: ChatRoomType.group,
      ),
    );

    if (!isChatCreated) return null;

    final isUsersAddedInChatRoom = await Future.wait(
      [
        _addUserInChat(
          chatId: chatId,
          chatRoomUser: ChatRoomUserDm(
            role: Role.admin,
            chatUser: null,
            userId: currentUserId,
            membershipStatusTimestamp: null,
            membershipStatus: MembershipStatus.member,
          ),
        ),
        for (var i = 0; i < userIdsLength; i++)
          if (ids[i] case final userId)
            _addUserInChat(
              chatId: chatId,
              chatRoomUser: ChatRoomUserDm(
                role: userIds[userId] ?? Role.admin,
                chatUser: null,
                userId: userId,
                membershipStatusTimestamp: null,
                membershipStatus: MembershipStatus.member,
              ),
            ),
      ],
    );

    final isAllUsersAddedInChatRoom = isUsersAddedInChatRoom.fold(
      true,
      (value, isAdded) => value && isAdded,
    );

    if (!isAllUsersAddedInChatRoom) {
      await deleteChat(chatId: chatId);
      throw Exception('Operation Failed! Unable to add all users in chat room');
    }

    final isChatAddedInAllUsers = await Future.wait([
      _createChatInUserChats(
        chatId: chatId,
        currentUserId: currentUserId,
        otherUserId: null,
      ),
      for (var i = 0; i < userIdsLength; i++)
        _createChatInUserChats(
          chatId: chatId,
          otherUserId: null,
          currentUserId: ids[i],
        ),
    ]);

    final isAllChatAddedInAllUsers = isChatAddedInAllUsers.fold(
      true,
      (value, isAdded) => value && isAdded,
    );

    if (!isAllChatAddedInAllUsers) {
      await deleteChat(chatId: chatId);
      throw Exception("Operation Failed! Unable to add chat in user's chats");
    }

    return chatId;
  }

  @override
  Future<bool> updateGroupChat({
    String? groupName,
    String? groupProfilePic,
  }) async {
    if (_chatRoomId == null) throw Exception("Chat Room ID can't be null");

    final data = <String, dynamic>{
      if (groupName?.isNotEmpty ?? false) _groupName: groupName,
      if (groupProfilePic != null) _groupPhotoUrl: groupProfilePic,
    };

    if (data.isEmpty) return true;

    try {
      await updateChatRoom(data: data);
      return true;
    } catch (_) {
      return false;
    }
  }

  /// To create one to one chat document at path of 'user_chats/[currentUserId]/chats/[chatId]' .
  Future<bool> _createChatInUserChats({
    required String chatId,
    required String currentUserId,
    required String? otherUserId,
  }) async {
    try {
      await ChatViewFireStoreCollections.userChatsConversationCollection(
        userId: currentUserId,
      ).doc(chatId).set(UserChatsConversationDm(userId: otherUserId));
      return true;
    } catch (_) {
      return false;
    }
  }

  Future<bool> _deleteChatFromUserChats({
    required String chatId,
    required String currentUserId,
  }) async {
    try {
      await ChatViewFireStoreCollections.userChatsConversationCollection(
        userId: currentUserId,
      ).doc(chatId).delete();
      return true;
    } catch (_) {
      return false;
    }
  }

  Future<String?> _createChatForOneToOne(
    String otherUserId, {
    String? chatRoomId,
  }) async {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) {
      throw Exception("Current User ID can't be null");
    }

    final chatId = chatRoomId ?? const Uuid().v8();

    final isChatCreated = await _createChat(
      chatId: chatId,
      chatRoom: ChatRoomDm(
        chatId: chatId,
        chatRoomType: ChatRoomType.oneToOne,
      ),
    );

    if (!isChatCreated) return null;

    final result = await Future.wait(
      [
        _addUserInChat(
          chatId: chatId,
          chatRoomUser: ChatRoomUserDm(
            role: Role.admin,
            chatUser: null,
            userId: currentUserId,
            membershipStatus: null,
            membershipStatusTimestamp: null,
          ),
        ),
        _addUserInChat(
          chatId: chatId,
          chatRoomUser: ChatRoomUserDm(
            role: Role.admin,
            chatUser: null,
            userId: otherUserId,
            membershipStatus: null,
            membershipStatusTimestamp: null,
          ),
        ),
      ],
    );

    final isCurrentUserCreated = result.firstOrNull ?? false;
    final isOtherUserCreated = result.lastOrNull ?? false;

    if (!isCurrentUserCreated && !isOtherUserCreated) {
      return null;
    } else if (isCurrentUserCreated && !isOtherUserCreated) {
      await deleteChat(chatId: chatId);
      return null;
    } else if (isOtherUserCreated && !isCurrentUserCreated) {
      await deleteChat(chatId: chatId);
      return null;
    } else {
      return chatId;
    }
  }

  Future<bool> _addUserInChat({
    required ChatRoomUserDm chatRoomUser,
    required String chatId,
  }) async {
    try {
      await ChatViewFireStoreCollections.chatUsersCollection(
        _chatRoomCollectionPath(chatId: chatId),
      ).doc(chatRoomUser.userId).set(chatRoomUser);
      return true;
    } catch (_) {
      return false;
    }
  }

  Future<bool> _createChat({
    required String chatId,
    required ChatRoomDm chatRoom,
  }) async {
    try {
      await ChatViewFireStoreCollections.chatCollection()
          .doc(chatId)
          .set(chatRoom);
      return true;
    } catch (_) {
      return false;
    }
  }

  @override
  Future<String?> isOneToOneChatExists(String otherUserId) async {
    try {
      final isOtherUserExist = await _isUserExists(otherUserId);
      if (!isOtherUserExist) {
        throw Exception('User ID($otherUserId) not exists');
      }
      return _isChatExists(otherUserId);
    } catch (_) {
      return null;
    }
  }

  Future<String?> _isChatExists(String otherUserId) async {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;
    if (currentUserId == null) {
      throw Exception("Current User ID can't be null");
    }

    final chatsSnapshot =
        await ChatViewFireStoreCollections.userChatsConversationCollection(
      userId: currentUserId,
    ).get();

    final docs = chatsSnapshot.docs;
    final docsLength = docs.length;
    for (var i = 0; i < docsLength; i++) {
      final doc = docs[i];
      final userId = doc.data()?.userId;
      if (userId == otherUserId) return doc.id;
    }
    return null;
  }

  Future<bool> _isUserExists(String userId) async {
    final result = await _usersollectionRef().doc(userId).get();
    return result.exists;
  }

  @override
  Future<bool> deleteChat({
    required String chatId,
    DeleteChatDocsFromStorageCallback? deleteChatDocsFromStorageCallback,
  }) async {
    final chatRoomCollectionPath = _chatRoomCollectionPath(chatId: chatId);

    final userCollection = ChatViewFireStoreCollections.chatUsersCollection(
      chatRoomCollectionPath,
    );

    final usersSnapshot = await userCollection.get();
    final usersSnapshotDocs = usersSnapshot.docs;
    final usersSnapshotDocsLength = usersSnapshotDocs.length;

    // List of asynchronous tasks for removing the chat room from each user's
    // chat list.
    final deletingChatRoomFromUsers = <Future<void>>[];

    // List of asynchronous tasks for removing users from the chat room.
    final deletingUsersFromChatRoom = <Future<void>>[];

    for (var i = 0; i < usersSnapshotDocsLength; i++) {
      final userId = usersSnapshotDocs[i].id;
      deletingChatRoomFromUsers.add(
        ChatViewFireStoreCollections.userChatsConversationCollection(
          userId: userId,
        ).doc(chatId).delete(),
      );
      deletingUsersFromChatRoom.add(
        ChatViewFireStoreCollections.chatUsersCollection(chatRoomCollectionPath)
            .doc(userId)
            .delete(),
      );
    }

    // Removes the chat room from each user's chat list
    // and users from the chat room.
    await Future.wait([
      ...deletingChatRoomFromUsers,
      ...deletingUsersFromChatRoom,
    ]);

    await _deleteNestedChatCollections(chatId);

    /// for deleting chat medias
    await deleteChatDocsFromStorageCallback?.call(chatId);
    return true;
  }

  Future<bool> _deleteNestedChatCollections(String chatId) async {
    try {
      final chatRoomCollection = _messageCollectionRef(chatId: chatId);

      final messagesSnapshot = await chatRoomCollection.get();

      final messagesSnapshotDocs = messagesSnapshot.docs;
      final messagesSnapshotDocsLength = messagesSnapshotDocs.length;

      await Future.wait([
        for (var i = 0; i < messagesSnapshotDocsLength; i++)
          chatRoomCollection.doc(messagesSnapshotDocs[i].id).delete(),
      ]);

      await ChatViewFireStoreCollections.chatCollection().doc(chatId).delete();

      return true;
    } catch (_) {
      return false;
    }
  }

  @override
  Future<bool> addUserInGroup({
    required String userId,
    required Role role,
  }) async {
    final chatRoomId = _chatRoomId;
    if (chatRoomId == null) throw Exception("Chat Room ID can't be null");

    final isUserExist = await _isUserExists(userId);
    if (!isUserExist) throw Exception('User ID ($userId) not exists');

    final chatRoom = await _isChatRoomExists(chatRoomId);
    if (chatRoom == null) {
      throw Exception('Chat Room ($chatRoomId) not exists');
    } else if (chatRoom.chatRoomType.isOneToOne) {
      throw Exception("User can't be added in one to one chat");
    }

    try {
      final userChatRoomCollection =
          ChatViewFireStoreCollections.chatUsersCollection(
        _chatRoomCollectionPath(),
      );

      final userChatRoomData = await userChatRoomCollection.doc(userId).get();

      final memberStatus = userChatRoomData.data()?.membershipStatus;

      if (memberStatus == null) {
        await userChatRoomCollection.doc(userId).set(
              ChatRoomUserDm(
                role: role,
                chatUser: null,
                userId: userId,
                membershipStatus: MembershipStatus.member,
                membershipStatusTimestamp: DateTime.now(),
              ),
            );
      } else if (!memberStatus.isMember) {
        await updateChatRoomUserMetadata(
          userId: userId,
          chatId: chatRoomId,
          membershipStatus: MembershipStatus.member,
        );
      } else {
        return true;
      }

      await ChatViewFireStoreCollections.userChatsConversationCollection(
        userId: userId,
      ).doc(chatRoomId).set(const UserChatsConversationDm());

      return true;
    } catch (_) {
      return false;
    }
  }

  @override
  Future<bool> removeUserFromGroup({
    required String userId,
    required bool deleteGroupIfSingleUser,
    required DeleteChatDocsFromStorageCallback
        deleteChatDocsFromStorageCallback,
  }) async {
    final currentUserId = ChatViewDbConnection.instance.currentUserId;

    final membershipStatus = currentUserId == userId
        ? MembershipStatus.left
        : MembershipStatus.removed;

    if (membershipStatus.isMember) throw Exception('In appropriate operation');

    final chatRoomId = _chatRoomId;
    if (chatRoomId == null) throw Exception("Chat Room ID can't be null");

    final isUserExist = await _isUserExists(userId);
    if (!isUserExist) throw Exception('User ID ($userId) not exists');

    final chatRoom = await _isChatRoomExists(chatRoomId);
    if (chatRoom == null) {
      throw Exception('Chat Room ($chatRoomId) not exists');
    }

    if (chatRoom.chatRoomType.isOneToOne) {
      throw Exception("User can't be removed from the one to one chat");
    }

    try {
      final userChatRoomCollection =
          ChatViewFireStoreCollections.chatUsersCollection(
        _chatRoomCollectionPath(),
      );

      ChatRoomUserDm? currentChatRoomUser;

      if (deleteGroupIfSingleUser) {
        final userChatRoomCollectionData = await userChatRoomCollection.get();

        final docs = userChatRoomCollectionData.docs;
        final docsLength = docs.length;

        var activeMembers = 0;

        for (var i = 0; i < docsLength; i++) {
          final chatRoomUser = docs[i].data();
          if (chatRoomUser == null) continue;
          if (chatRoomUser.userId == userId) currentChatRoomUser = chatRoomUser;
          if (chatRoomUser.membershipStatus?.isMember ?? false) activeMembers++;
        }

        if (activeMembers == 1) {
          final result = await deleteChat(
            chatId: chatRoomId,
            deleteChatDocsFromStorageCallback:
                deleteChatDocsFromStorageCallback,
          );
          return result;
        }
      } else {
        final userChatRoomData = await userChatRoomCollection.doc(userId).get();
        currentChatRoomUser = userChatRoomData.data();
      }

      if (currentChatRoomUser != null &&
          currentChatRoomUser.membershipStatus != membershipStatus) {
        await updateChatRoomUserMetadata(
          userId: userId,
          chatId: chatRoomId,
          membershipStatus: membershipStatus,
        );
      }

      await ChatViewFireStoreCollections.userChatsConversationCollection(
        userId: userId,
      ).doc(chatRoomId).delete();

      return true;
    } catch (_) {
      return false;
    }
  }

  Future<ChatRoomDm?> _isChatRoomExists(String chatRoomId) async {
    final result = await ChatViewFireStoreCollections.chatCollection()
        .doc(chatRoomId)
        .get();
    return result.data();
  }

  @override
  Stream<ChatRoomMetadata> getGroupChatMetadataStream([String? chatId]) {
    final newChatId = chatId ?? _chatRoomId;
    if (newChatId == null) throw Exception("Chat Room ID can't be null");

    return ChatViewFireStoreCollections.chatCollection()
        .doc(newChatId)
        .snapshots()
        .distinct(
      (previous, next) {
        final previousData = previous.data();
        final nextData = next.data();
        return previousData?.groupName == nextData?.groupName &&
            previousData?.groupPhotoUrl == nextData?.groupPhotoUrl;
      },
    ).map(
      (chatRoomSnapshot) {
        final chatRoom = chatRoomSnapshot.data();
        if (chatRoom == null || !chatRoom.chatRoomType.isGroup) {
          throw Exception('No Group Chat Found');
        }
        return ChatRoomMetadata(
          chatName: chatRoom.groupName ?? 'Unknown Group',
          chatProfilePhoto: chatRoom.groupPhotoUrl,
        );
      },
    );
  }

  @override
  Future<DateTime?> userAddedInGroupChatTimestamp({
    String? userId,
    String? chatId,
  }) async {
    final newUserId = userId ?? ChatViewDbConnection.instance.currentUserId;
    if (newUserId == null) throw Exception("User ID can't be null");

    final newChatId = chatId ?? _chatRoomId;
    if (newChatId == null) throw Exception("Chat ID can't be null");

    final chatRoomUserData =
        await ChatViewFireStoreCollections.chatUsersCollection(
      _chatRoomCollectionPath(chatId: newChatId),
    ).doc(newUserId).get();

    final chatRoomUser = chatRoomUserData.data();

    return switch (chatRoomUser?.membershipStatus) {
      MembershipStatus.member => chatRoomUser?.membershipStatusTimestamp,
      null || MembershipStatus.removed || MembershipStatus.left => null,
    };
  }

  @override
  Future<bool> updateChatRoom({
    String? chatId,
    Message? lastMessage,
    Map<String, dynamic>? data,
  }) async {
    final newChatId = chatId ?? _chatRoomId;
    if (newChatId == null) throw Exception("Chat Room ID can't be null");

    try {
      await ChatViewFireStoreCollections.chatCollection()
          .doc(newChatId)
          .update(data ?? {_lastMessage: lastMessage?.toJson()});
      return true;
    } catch (_) {
      return false;
    }
  }

  @override
  Future<bool> fetchAndUpdateLastMessage({String? chatId}) async {
    try {
      final messageCollectionRef = _messageCollectionRef(chatId: chatId)
          .orderBy(
            MessageSortBy.dateTime.key,
            descending: MessageSortOrder.desc.isDesc,
          )
          .limit(1);

      final result = await messageCollectionRef.get();
      final lastMessage = result.docs.lastOrNull?.data();

      return updateChatRoom(chatId: chatId, lastMessage: lastMessage);
    } catch (_) {
      return false;
    }
  }

  @override
  Stream<ChatRoomMetadata> getChatRoomMetadataStream({
    required ChatRoomType chatRoomType,
    String? userId,
    String? chatId,
  }) {
    assert(
      chatRoomType.isGroup || chatRoomType.isOneToOne && userId != null,
      "User Id can't be null",
    );
    return switch (chatRoomType) {
      ChatRoomType.oneToOne when userId != null =>
        getUserStreamById(userId: userId).map(
          (user) => ChatRoomMetadata(
            chatName: user?.name ?? 'Unknown User',
            chatProfilePhoto: user?.profilePhoto,
          ),
        ),
      ChatRoomType.group => getGroupChatMetadataStream(),
      _ => Stream.value(
          const ChatRoomMetadata(chatName: 'Unknown User'),
        ),
    };
  }

  ChatRoomParticipantsRecord _getChatRoomParticipant(
    List<ChatRoomUserDm> users,
  ) {
    final usersLength = users.length;
    final currentUserId = ChatViewDbConnection.instance.currentUserId;

    ChatRoomUserDm? currentUser;
    final otherUsers = <ChatRoomUserDm>[];

    for (var i = 0; i < usersLength; i++) {
      final user = users[i];
      if (user.userId == currentUserId) {
        currentUser = user;
      } else {
        otherUsers.add(user);
      }
    }

    return (currentUser: currentUser, otherUsers: otherUsers);
  }

  Stream<UserInfoWithStatusRecord> _getUserInfoWithStatusStream(String userId) {
    return Rx.combineLatest2(
      getUserStreamById(userId: userId),
      ChatViewFireStoreCollections.userChatCollection().doc(userId).snapshots(),
      (userInfo, userStatusSnapshot) => (
        user: userInfo,
        userStatus: userStatusSnapshot.data()?.userStatus,
      ),
    );
  }
}
