import 'package:chatview/chatview.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

import '../../../flutter_chatview_db_connection.dart';
import '../../enum.dart';
import '../../extensions.dart';
import '../../models/config/add_message_config.dart';
import '../../typedefs.dart';
import '../database_service.dart';
import 'chatview_firestore_collections.dart';

/// provides methods for getting, adding, updating and deleting message
/// and messages streams from Firebase Firestore.
final class ChatViewFireStoreDatabase implements DatabaseService {
  static const String _status = 'status';
  static const String _reaction = 'reaction';

  static ChatDatabasePathConfig? _chatDatabaseConfig;

  String? _chatRoomCollectionPath({String? chatId}) {
    final newChatId = chatId ?? _chatDatabaseConfig?.chatRoomId;
    final collectionPath =
        '${_chatDatabaseConfig?.chatRoomCollectionPath}/$newChatId';
    assert(
      collectionPath.isValidFirestoreDocument,
      'invalid Firestore document path provided',
    );
    return collectionPath;
  }

  CollectionReference<Message?> _messageCollectionRef({String? chatId}) =>
      ChatViewFireStoreCollections.messageCollection(
        _chatRoomCollectionPath(chatId: chatId),
      );

  @override
  void setConfiguration({required ChatDatabasePathConfig config}) =>
      _chatDatabaseConfig = config;

  @override
  void resetConfiguration() => _chatDatabaseConfig = null;

  @override
  Future<Message?> addMessage(
    Message message, {
    required bool useAutoGeneratedId,
    required AddMessageConfig addMessageConfig,
  }) async {
    final url = await addMessageConfig.uploadDocumentFromMessage(message);
    final messageCollectionRef = _messageCollectionRef();
    final newMessage = message.copyWith(message: url);
    if (useAutoGeneratedId) {
      final result = await messageCollectionRef.add(newMessage);
      return newMessage.copyWith(id: result.id);
    } else {
      await messageCollectionRef.doc(newMessage.id).set(newMessage);
      return newMessage;
    }
  }

  @override
  Stream<List<MessageDm>> getMessagesStream({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
  }) {
    final messageCollectionRef = _messageCollectionRef().toQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messages = docSnapshot.docs;
        final messagesLength = messages.length;
        return [
          for (var i = 0; i < messagesLength; i++)
            if (messages[i].data() case final message?)
              MessageDm(
                message: message.copyWith(id: messages[i].id),
                snapshot: messages[i],
              ),
        ];
      },
    );
  }

  @override
  Stream<Map<Message, DocumentType>> getMessagesStreamWithOperationType({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
  }) {
    final messageCollectionRef = _messageCollectionRef().toQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
    );

    return messageCollectionRef.snapshots().distinct().map(
      (docSnapshot) {
        final messagesChanges = docSnapshot.docChanges;
        final messagesChangesLength = messagesChanges.length;
        final messages = <Message, DocumentType>{};
        for (var i = 0; i < messagesChangesLength; i++) {
          final changedDoc = messagesChanges[i];
          final messageDoc = changedDoc.doc;
          final message = messageDoc.data()?.copyWith(id: messageDoc.id);
          if (message == null) continue;
          messages[message] = changedDoc.type.toDocumentType();
        }
        return messages;
      },
    );
  }

  @override
  Future<List<MessageDm>> getMessages({
    required MessageSortBy sortBy,
    required MessageSortOrder sortOrder,
    int? limit,
    DocumentSnapshot<Message?>? startAfterDocument,
  }) async {
    final messageCollectionRef = _messageCollectionRef().toQuery(
      sortBy: sortBy,
      sortOrder: sortOrder,
      limit: limit,
      startAfterDocument: startAfterDocument,
    );

    final result = await messageCollectionRef.get();
    final docs = result.docs;
    final docsLength = docs.length;
    return [
      for (var i = 0; i < docsLength; i++)
        if (docs[i].data() case final message?)
          MessageDm(
            message: message.copyWith(id: docs[i].id),
            snapshot: docs[i],
          ),
    ];
  }

  @override
  Future<bool> deleteMessage(
    Message message, {
    required DeleteDocumentCallback onDeleteDocument,
    required bool deleteImageFromStorage,
    required bool deleteVoiceFromStorage,
  }) async {
    final messageType = message.messageType;
    if (messageType.isImage && deleteImageFromStorage) {
      await onDeleteDocument(message);
    } else if (messageType.isVoice && deleteVoiceFromStorage) {
      await onDeleteDocument(message);
    }
    await _messageCollectionRef().doc(message.id).delete();
    return true;
  }

  @override
  Future<void> updateMessage(
    Message message, {
    MessageStatus? messageStatus,
    UserReactionCallback? userReaction,
  }) async {
    final data = <String, dynamic>{};

    if (messageStatus != null) data[_status] = messageStatus.name;
    if (userReaction != null) data[_reaction] = message.reaction.toJson();

    if (data.isEmpty) return;

    return _messageCollectionRef().doc(message.id).update(data);
  }
}
